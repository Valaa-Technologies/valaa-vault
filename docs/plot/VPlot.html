<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <title>ValOS Path</title>
    <script
     src='https://www.w3.org/Tools/respec/respec-w3c-common'
     class='remove'></script>
    <script class='remove'>
      var respecConfig = {"specStatus":"unofficial","editors":[{"name":"Iridian Kiiskinen","url":"https://valaatech.github.io/fabric/authors/iridian","github":"http://github.com/valospace"}],"authors":[],"shortName":"VPlot"};
    </script>
    <link rel = "stylesheet" type = "text/css" href = "/summary.css" />
    
  </head>
  <body class="vdoc vdoc-body">
    
  <section id="abstract" class="vdoc type-vdoc-chapter"><div><p>
  <div class="vdoc type-vdoc-paragraph">ValOS Plots (&#x27;VPlots&#x27;) are general purpose semantic strings with a
recursive grammar and a limited character set that makes them easily
URI embeddable.
  </div>
</p></div><div><p>
  <div class="vdoc type-vdoc-paragraph">A step below JSON in generality they are the fundamental
primitive used by valos to implement resource identifiers, valospace
queries, deterministic JSON serialization, an intermediate language
for computation, a configuration language, JSON-LD interactions and
more.
  </div>
</p></div><div><p>
  <div class="vdoc type-vdoc-paragraph">VPlots have a formalized mechanism for making parameterized use of
context-specific definitions. This enables integrations to semantic
web. This context-specific yet formally semantic system forms the
cornerstone of valos security architecture.
  </div>
</p></div>
  </section>

  <section id="sotd" class="vdoc type-vdoc-chapter"><div><p>
  <div class="vdoc type-vdoc-paragraph">This document is part of the library workspace <a href="https://valospace.org/raem" class="vdoc type-vrevdoc-package"><em>@valos/raem</em></a>
but is only partially implemented by it.
  </div>
</p></div>
  </section>

  <section id="introduction" class="vdoc type-vdoc-chapter"><div><p>
  <div class="vdoc type-vdoc-paragraph">
A subset of VPlots called &#x27;vrids&#x27; contain a fixed starting point and
identify valospace resources.
  </div>
</p></div><div><p>
  <div class="vdoc type-vdoc-paragraph">VPlots contain &#x27;context terms&#x27; which refer to definitions provided by
the surrounding context, usually as references to some external
ontology. This allows VPlot semantics to be extended in domain
specific but reusable manner.
  </div>
</p></div><div><p>
  <div class="vdoc type-vdoc-paragraph">The primary example of a VPlot context is the JSON-LD @context of a <a href="https://valospace.org/sourcerer/valos-event-log" class="vdoc type-vdoc-reference">ValOS event chronicle</a>
which provides the semantics for all VPlots that appear inside the
chronicle.
    
  </div>
</p></div>
  </section>

  <section id="section_structure" class="vdoc type-vdoc-chapter">
    <h3><a aria-label="§" href="#section_structure">§ </a>VPlot structure</h3>
<div><p>
  <div class="vdoc type-vdoc-paragraph">VPlot grammar only adds &#x22;@&#x22; and &#x22;$&#x22; in addition to
encodeURIComponent characters. VPlot grammar has two primary building
blocks: vsteps and vparams.
  </div>
</p></div>
    <ul>
      <li>A VPlot itself is an ordered sequence of &#x22;@&#x22;-separated vsteps, each
  of which logically depends on the preceding one.</li>
      <li><div><p>
  <div class="vdoc type-vdoc-paragraph">A vstep can have a &#x27;verb type&#x27; and a sequence of vparams, all
  logically independent of each other.
  </div>
</p></div></li>
      <li><div><p>
  <div class="vdoc type-vdoc-paragraph">A vparam always contains a &#x22;$&#x22;-prefix. The vparam then has
  an optional context-term and finally a &#x22;.&#x22;-prefixed vvalue.
  </div>
</p></div></li>
    </ul>
<div><p>
  <div class="vdoc type-vdoc-paragraph">VPlots serve two superficially distinct purposes as paths and as
identifiers. If the first vstep of a VPlot begins with a context term
(ie. doesn&#x27;t have a verb type) then the whole VPlot is valospace
resource identifier (a *VRID*) and the first vstep is a valospace
global resource identifier (a *VGRID*).
  </div>
</p></div>
<blockquote class="vdoc type-revdoc-example">
    <span id="main_vplot_rules" class="vdoc type-vdoc-node">
    <h3><a aria-label="§" href="#main_vplot_rules">§ </a>Main VPlot rules</h3>
<pre><code><span class="vdoc type-vdoc-node">  vplot = &#x22;@&#x22; *(vstep &#x22;@&#x22;) &#x22;@&#x22;
  vstep  = [ verb-type ] *vparam
  vparam = &#x22;$&#x22; [ context-term ] &#x22;.&#x22; vvalue
  vvalue = vplot / &#x22;$&#x22; / 1*( unencoded / pct-encoded )</span>
</code></pre></span>

</blockquote>
  <section id="section_vrid_structure" class="vdoc type-vdoc-chapter">
    <h3><a aria-label="§" href="#section_vrid_structure">§ </a>VPlot with a VGRID is a resource identifier: a VRID</h3>
<div><p>
  <div class="vdoc type-vdoc-paragraph">
A VPlot with a first vstep lacking a verb type and no other vsteps
identifies a global resource.
  </div>
</p></div><div><p>
  <div class="vdoc type-vdoc-paragraph">Many valospace resources, so called *fixed sub-resources* are
identified by a fixed path from the global resource defined by the same
verbs that define non-VRID VPlots. Thus while paths and identifiers are
superficially different it is useful to represent them both using the
same VPlot verb structure.
  </div>
</p></div><div><p>
  <div class="vdoc type-vdoc-paragraph">Both verb and VGRID params can also have context term references to
an external lookup of URI prefixes and semantic definitions.
  </div>
</p></div>
  </section>

  <section id="section_representations" class="vdoc type-vdoc-chapter">
    <h3><a aria-label="§" href="#section_representations">§ </a>VPlot representations</h3>
<div><p>
  <div class="vdoc type-vdoc-paragraph">
The canonical VPlot is a string, but there are other format specific
representations.
      
  </div>
</p></div>
  <section id="section_vplot_urn" class="vdoc type-vdoc-chapter">
    <h3><a aria-label="§" href="#section_vplot_urn">§ </a>VPlot URN-scheme (tentative)</h3>
<div><p>
  <div class="vdoc type-vdoc-paragraph">
A VRID VPlot string can be expressed as an URN by removing the &#x22;@&#x22;
prefix and the &#x22;@@&#x22; suffix and then prefixing the string with
&#x60;urn:valos:&#x60;.

  </div>
</p></div>
<blockquote class="vdoc type-revdoc-example">
    <span class="vdoc type-vdoc-node">
Editorial Note: the urn:valos is fully speculative as of 2019-11. On
one hand there is salient overlap between valos VRID and URN
principles: URN calls for structured and managed process of name
assignment and resolution and VRID system is precisely that. On the
other hand VRID defers a lot of detail to specific VGRID format-term
specifications which might prove problematic for actual standardization
process. It is possible that instead of a generic urn:valos namespace
there would be specific urn namespaces for specific VRID formats (e.g.
urn:valos-u4, urn:valos-cc) or that urn:valos would stand for one
specific format (which would most likely be the ~cc).</span>

</blockquote>
  </section>

  <section id="section_segmented_vplots" class="vdoc type-vdoc-chapter">
    <h3><a aria-label="§" href="#section_segmented_vplots">§ </a>Segmented VPlot representation</h3>
<div><p>
  <div class="vdoc type-vdoc-paragraph">
Segmented VPlot is a recursive partitioning of a VPlot as a JSON object
where each structural segment is expressed as an array. The first entry
of each such segment is a string which denotes the segment type and the
remaining entries contain the segment payload:

  </div>
</p></div>
    <ul>
      <li>&#x22;@&#x22; identifies a VPlot segment with remaining entries as step
  segments</li>
      <li><div><p>
  <div class="vdoc type-vdoc-paragraph">&#x22;$&#x22; identifies a vparam segment with its second entry being a valid
  context term string and an optional third entry containing the vvalue
  </div>
</p></div></li>
      <li><div><p>
  <div class="vdoc type-vdoc-paragraph">&#x22;$.&#x22; identifies a vparam segment without a context-term and with an
  optional second entry containing the vvalue
  </div>
</p></div></li>
      <li><div><p>
  <div class="vdoc type-vdoc-paragraph">otherwise the segment type denotes the verb type of a verb segment
  and remaining entries containing the parameter segments
  </div>
</p></div></li>
    </ul>
<div><p>
  <div class="vdoc type-vdoc-paragraph">
JSON numbers and strings can only appear as param values of &#x22;$&#x22; or
&#x22;$.&#x22;-segments. JSON objects cannot appear.
A VPlot which is used as a contextless param of a verb must appear
directly without intermediate &#x22;$.&#x22;-segments (unlike in the string VPlot
construct).
Conversely a verb used as a contextless param must still be wrapped
inside a &#x22;@&#x22;-segment.
  </div>
</p></div>
  </section>

  <section id="section_shortcut_vplots" class="vdoc type-vdoc-chapter">
    <h3><a aria-label="§" href="#section_shortcut_vplots">§ </a>Shortcut VPlot representation</h3>
<div><p>
  <div class="vdoc type-vdoc-paragraph">
Shortcut VPlot format is a compact object representation of a VPlot as
&#x27;human readable&#x27; JSON which can then be distributed to the canonical
representation. In fact any JSON construct is a valid shortcut VPlot,
and as long as all initial array entries equal to &#x22;@&#x22;, &#x22;$&#x22; and &#x22;$.&#x22; are
escaped as [&#x22;$.&#x22;, &#x22;@&#x22;], [&#x22;$.&#x22;, &#x22;$&#x22;] and [&#x22;$.&#x22;, &#x22;$.&#x22;] the shortcut
segment will resolve back into the original JSON construct.

  </div>
</p></div>
  </section>

  <section id="section_cemented_vplots" class="vdoc type-vdoc-chapter">
    <h3><a aria-label="§" href="#section_cemented_vplots">§ </a>Cemented VPlots</h3>
<div><p>
  <div class="vdoc type-vdoc-paragraph">
VPlots contain context references but do not _contain_ knowledge about
the context. This is to ensure that a VPlot can be moved from a context
to a compabible one without modification.
  </div>
</p></div><div><p>
  <div class="vdoc type-vdoc-paragraph">Cementing a VPlot with a context inside an environment produces a
construct where the VPlot itself and specifically its context terms are
converted to their environment-specific representations. This
representation can be anything from interpretable JSON to fully
compiled executable code.
  </div>
</p></div><div><p>
  <div class="vdoc type-vdoc-paragraph">Cementing also performs the security critical function of validating
the context terms and their parameters against their context inside
that particular environment (e.g. a typical validation failure being
the lack of implementation for a specific context term by the
environment).
  </div>
</p></div>
  </section>

  </section>

  </section>

  <section id="section_semantics" class="vdoc type-vdoc-chapter">
    <h3><a aria-label="§" href="#section_semantics">§ </a>VPlot semantics</h3>
<div><p>
  <div class="vdoc type-vdoc-paragraph">The full semantics of a particular VPlot string in some environment
comes from several different sources:
  </div>
</p></div>
    <ol>
      <li>VPlot specification (ie. this document) fully specifies the VPlot
  structure and grammar and defines several verb types</li>
      <li><div><p>
  <div class="vdoc type-vdoc-paragraph">VPlot extension specifications can define additional conforming verb type semantics
  </div>
</p></div></li>
      <li><div><p>
  <div class="vdoc type-vdoc-paragraph">VPlot environment can define context terms directly
  </div>
</p></div></li>
      <li><div><p>
  <div class="vdoc type-vdoc-paragraph">VPlot environment can delegate context term definitions to external
  ontologies
  </div>
</p></div></li>
    </ol>

  <section id="section_equivalence" class="vdoc type-vdoc-chapter">
    <h3><a aria-label="§" href="#section_equivalence">§ </a>VPlot equivalence follows URN equivalence</h3>
<div><p>
  <div class="vdoc type-vdoc-paragraph">
Two VPlots identify the same path (and in case they&#x27;re VRIDs, refer to
the same resource) iff their URN representations are <a href="https://tools.ietf.org/html/rfc8141#section-3" class="vdoc type-vdoc-reference">urn-equivalent</a> and 1. they either share the same environment or 2. their
corresponding context terms expand to URIs which are pair-wise
URI-equivalent.
  </div>
</p></div><div><p>
  <div class="vdoc type-vdoc-paragraph">For the general case the actual semantics of a VPlot and specifically
of its context-term&#x27;s depends on the context it is used. Vrids have a
fixed context which is established by the VGRID. <a href="https://valospace.org/plot#section_vrid_equivalence" class="vdoc type-vdoc-reference">This has implications on VRID equivalence</a>.
  </div>
</p></div>
  </section>

  <section id="section_context_term" class="vdoc type-vdoc-chapter">
    <h3><a aria-label="§" href="#section_context_term">§ </a> &#x27;context-term&#x27; is a lookup to definitions provided by the context</h3>
<div><p>
  <div class="vdoc type-vdoc-paragraph">
A VPlot can be contextual via the vparam context-term&#x27;s. These are
case-sensitive strings with very restricted grammar. The context where
the VPlot is used defines the exact meaning of these terms.
The meaning for two identical context-terms is recommended to be
uniform across domains where possible.
A VPlot is invalid in contexts which don&#x27;t have definitions for the
context-terms of all of its steps. This gives different contexts
a fine-grained mechanism for defining the vocabularies that are
available.
  </div>
</p></div><div><p>
  <div class="vdoc type-vdoc-paragraph">Idiomatic example of such context is the event log and its JSON-LD
context structure which is to define both URI namespace prefixes as
well as available semantics.
  </div>
</p></div>
  </section>

  <section id="section_vparam_value" class="vdoc type-vdoc-chapter">
    <h3><a aria-label="§" href="#section_vparam_value">§ </a>&#x27;vvalue&#x27; carries content</h3>
<div><p>
  <div class="vdoc type-vdoc-paragraph">
*vparams* is a sequence of vparam&#x27;s, optionally prefixed with
&#x22;$&#x22; and a context-term. The idiomatic vvalue is a string.
If present a context-term may denote a URI prefix in which case the
vvalue forms the suffix of the full expanded URI reference.
However contexts are free to provide specific semantics for specific
context-terms, such as interpreting them as the value type of the
vvalue etc.
  </div>
</p></div><div><p>
  <div class="vdoc type-vdoc-paragraph">&#x22;$&#x22; for a vvalue denotes empty string.
  </div>
</p></div><div><p>
  <div class="vdoc type-vdoc-paragraph">*vvalue* both allows for fully
unencoded nesting of VPlot&#x27;s as well as allows encoding of all unicode
characters in percent encoded form (as per encodeURIComponent)
  </div>
</p></div>
  </section>

  <section id="section_semantic_considerations" class="vdoc type-vdoc-chapter">
    <h3><a aria-label="§" href="#section_semantic_considerations">§ </a>Semantic design choices and guidelines</h3>
<div><p>
  <div class="vdoc type-vdoc-paragraph">As VPlot structure is expressive there are often multiple ways to
express a particular design need. Following juxtapositions and
guidelines apply:
  </div>
</p></div>
    <ul>
      <li>&#x22;vsteps vs. vparams&#x22; or &#x22;How should I express a sequence?&#x22;:
  If the entries of a sequence depend on each other (e.g. in a query or
  in an execution list) they are vsteps, if not (e.g. data entries)
  they are vparams of a vstep.</li>
      <li><div><p>
  <div class="vdoc type-vdoc-paragraph">&#x22;verb type vs. context term&#x22; or &#x22;How should I express a concept?&#x22;:
  If the concept is interaction logic, domain specific, visible to the
  end-users or it doesn&#x27;t require infrastructure code changes it is
  probably a context term with URI expansion to some ontology.
  If the concept concerns VPlot structure or its interpretation and is
  generic enough to warrant a specification and corresponding
  infrastructure implementation work it is possibly a verb type with
  new extension spec or new release of an existing spec.
  </div>
</p></div></li>
      <li><div><p>
  <div class="vdoc type-vdoc-paragraph">&#x22;!-computational vs. declarational&#x22; or &#x22;Who writes the code?&#x22;:
  Computational vsteps (those with verb type beginning with &#x22;!&#x22;) allow
  for turing-complete computation to be embedded inside VPlots. An
  environment that chooses to support these verbs and context terms
  has the upside of rapid and arbitrarily expressive configurability
  without further code changes. The downside is that security and
  complexity analysis becomes intractable even more rapidly.
  Declarational vsteps (all other verb types) require explicit
  interpretation but should be preferred when meaningful semantics can
  be specified.
  </div>
</p></div></li>
    </ul>

  </section>

  <section id="section_verb" class="vdoc type-vdoc-chapter">
    <h3><a aria-label="§" href="#section_verb">§ </a>*verb* - a vstep from a source resource to target resource(s)</h3>
<div><p>
  <div class="vdoc type-vdoc-paragraph">
A verb is a one-to-maybe-many relationship between resources. A verb
can be as simple as a trivial predicate of a triple or it can represent
something as complex as a fully parameterized computational function
call.
  </div>
</p></div>
<blockquote class="vdoc type-revdoc-example">
    <span id="main_verb_rules" class="vdoc type-vdoc-node">
    <h3><a aria-label="§" href="#main_verb_rules">§ </a>Informative verb rules</h3>
<pre><code><span class="vdoc type-vdoc-node">  vverb        = verb-type *vparam
  vparam       = &#x22;$&#x22; [ context-term ] &#x22;.&#x22; vvalue
  verb-type    = 1*unencoded
  context-term = ALPHA *unreserved-nt
  vvalue       = vplot / &#x22;$&#x22; / 1*( unencoded / pct-encoded )
</span>
</code></pre></span>

</blockquote><div><p>
  <div class="vdoc type-vdoc-paragraph">
A verb is made up of verb type and a sequence of vparams. The grammar
of verb-type is restricted but less than for context-term.  The verb
type semantics is always fixed. Because of this the first vparam may be
semantically special and act as a contextual name of the verb.

  </div>
</p></div>
  <section id="section_verb_type" class="vdoc type-vdoc-chapter">
    <h3><a aria-label="§" href="#section_verb_type">§ </a>*verb-type*</h3>
<div><p>
  <div class="vdoc type-vdoc-paragraph">
*verb-type* specifies the relationship category between the segment
host resource and sub-resource, a set of inferred triples as well as
other possible constraints.
  </div>
</p></div>
  <section id="section_verb_property" class="vdoc type-vdoc-chapter">
    <h3><a aria-label="§" href="#section_verb_property">§ </a>verb type &#x22;&#x60;.&#x60;&#x22;: property or ScopeProperty selector</h3>
<div><p>
  <div class="vdoc type-vdoc-paragraph">
Verb for selecting the resource (typically a ScopeProperty) with the
given name and which has the head as its scope.
  </div>
</p></div>
<blockquote class="vdoc type-revdoc-example">
    <span id="example_verb_property" class="vdoc type-vdoc-node">
    <h3><a aria-label="§" href="#example_verb_property">§ </a>Property selector example</h3>
Triple pattern &#x60;?s &#x3C;urn:valos:.$.myProp&#x3E; ?o&#x60; matches like:
<pre><code><span class="vdoc type-vdoc-node">
  ?o    V:scope ?s
      ; V:name &#x22;myProp&#x22;
</span>
</code></pre>Mnemonic: &#x27;.&#x27; is traditional property accessor (ie. ScopeProperty).</span>

</blockquote>
  </section>

  <section id="section_verb_sequence" class="vdoc type-vdoc-chapter">
    <h3><a aria-label="§" href="#section_verb_sequence">§ </a>verb type &#x22;&#x60;*&#x60;&#x22;: sequence or Relation selector</h3>
<div><p>
  <div class="vdoc type-vdoc-paragraph">
Verb for selecting all resources (typically Relations) with the given
name and which have the head as their source.
  </div>
</p></div>
<blockquote class="vdoc type-revdoc-example">
    <span id="example_verb_sequence" class="vdoc type-vdoc-node">
    <h3><a aria-label="§" href="#example_verb_sequence">§ </a>Sequence selector example</h3>
Triple pattern &#x60;?s &#x3C;urn:valos:-out--$.PERMISSIONS&#x3E; ?o&#x60; matches like:
<pre><code><span class="vdoc type-vdoc-node">
  ?o    V:source ?s
      ; V:name &#x22;PERMISSIONS&#x22;
</span>
</code></pre>
Mnemonic: &#x27;*&#x27; for many things as per regex/glob syntax (Relations are
the only things that can have multiple instances with the same name).</span>

</blockquote>
  </section>

  <section id="section_verb_container" class="vdoc type-vdoc-chapter">
    <h3><a aria-label="§" href="#section_verb_container">§ </a>verb type &#x22;&#x60;+&#x60;&#x22;: container or Entity selector</h3>
<div><p>
  <div class="vdoc type-vdoc-paragraph">
Verb for selecting the resource (typically an Entity) with the given
name and which has the head as their container.
  </div>
</p></div>
<blockquote class="vdoc type-revdoc-example">
    <span id="example_verb_container" class="vdoc type-vdoc-node">
    <h3><a aria-label="§" href="#example_verb_container">§ </a>Container selector example</h3>
Triple pattern &#x60;?s &#x3C;urn:valos:+$.Scripts&#x3E; ?o&#x60; matches like:
<pre><code><span class="vdoc type-vdoc-node">
  ?o    V:parent ?s
      ; V:name &#x22;Scripts&#x22;
</span>
</code></pre>
Mnemonic: &#x22;+&#x22; is a list-view symbol of an expandable container.</span>

</blockquote>
  </section>

  <section id="section_verb_content" class="vdoc type-vdoc-chapter">
    <h3><a aria-label="§" href="#section_verb_content">§ </a>verb type &#x22;&#x60;~&#x60;&#x22;: content or Media selector</h3>
<div><p>
  <div class="vdoc type-vdoc-paragraph">
Verb for selecting the Media with the given name which has the
head as their folder.
  </div>
</p></div>
<blockquote class="vdoc type-revdoc-example">
    <span id="example_verb_content" class="vdoc type-vdoc-node">
    <h3><a aria-label="§" href="#example_verb_content">§ </a>Content selector example</h3>
Triple pattern &#x60;?s &#x3C;urn:valos:~$.foo.vs&#x3E; ?o&#x60; matches like:
<pre><code><span class="vdoc type-vdoc-node">
  ?o    V:folder ?s
      ; V:name &#x22;foo.vs&#x22;
</span>
</code></pre>
Mnemonic: &#x22;~&#x22; has no mnemonic yet.</span>

</blockquote>
  </section>

  <section id="section_verb_object" class="vdoc type-vdoc-chapter">
    <h3><a aria-label="§" href="#section_verb_object">§ </a>verb type &#x22;&#x60;.O&#x60;&#x22;: object or target selector</h3>
<div><p>
  <div class="vdoc type-vdoc-paragraph">
Verb that is a synonym for predicate &#x27;rdf:object&#x27;.
  </div>
</p></div>
<blockquote class="vdoc type-revdoc-example">
    <span id="example_verb_object" class="vdoc type-vdoc-node">
    <h3><a aria-label="§" href="#example_verb_object">§ </a>Property selector example</h3>
Triple pattern &#x60;?s &#x3C;urn:valos:.O&#x3E; ?o&#x60; matches like:
<pre><code><span class="vdoc type-vdoc-node">
  ?s    rdf:object ?o
</span>
</code></pre>
Mnemonic: follow line &#x27;-&#x27; to target.</span>

</blockquote>
  </section>

  <section id="section_verb_ghost" class="vdoc type-vdoc-chapter">
    <h3><a aria-label="§" href="#section_verb_ghost">§ </a>verb type &#x22;&#x60;_&#x60;&#x22;: subspace selector</h3>
<div><p>
  <div class="vdoc type-vdoc-paragraph">
Verb for selecting named subspaces and ghosts.
  </div>
</p></div>
<blockquote class="vdoc type-revdoc-example">
    <span id="example_verb_language_subspace" class="vdoc type-vdoc-node">
    <h3><a aria-label="§" href="#example_verb_language_subspace">§ </a>Language subspace selector example</h3>
Triple pattern &#x60;?s &#x3C;urn:valos:.$.myProp@_$lang.fi&#x3E; ?o&#x60; matches like:
<pre><code><span class="vdoc type-vdoc-node">
  ?_sp  V:scope ?s
      ; V:name &#x22;myProp&#x22;
  . ?o  V:subspacePrototype* ?_sp
      ; V:language &#x22;fi&#x22;
</span>
</code></pre>
Mnemonic: &#x27;_&#x27; is underscore is subscript is subspace.</span>

</blockquote><div><p>
  <div class="vdoc type-vdoc-paragraph">If the verb name context term is an identifier term then the subspace
denotes the ghost subspace of the identified resource inside the
current resource.
  </div>
</p></div>
<blockquote class="vdoc type-revdoc-example">
    <span id="example_verb_ghost_subspace" class="vdoc type-vdoc-node">
    <h3><a aria-label="§" href="#example_verb_ghost_subspace">§ </a>Ghost subspace selector example</h3>
Triple pattern &#x60;?s &#x3C;urn:valos:_$~u4.ba54&#x3E; ?o&#x60; matches like:
<pre><code><span class="vdoc type-vdoc-node">
  ?o    V:ghostHost ?s
      ; V:ghostPrototype &#x3C;urn:valos:$~u4.ba54&#x3E;
</span>
</code></pre>
Mnemonic: The &#x27;_$~&#x27; is a &#x27;subspace of ghoStS&#x27;.</span>

</blockquote>
  </section>

  <section id="section_verb_computation" class="vdoc type-vdoc-chapter">
    <h3><a aria-label="§" href="#section_verb_computation">§ </a>verb type &#x22;&#x60;!&#x60;&#x22;: computation evaluators</h3>
<div><p>
  <div class="vdoc type-vdoc-paragraph">
VPlots are data. In general whenever a representation of a VPlot
appears in some <em>evaluation context</em> the representation
evaluates into itself. The only exception are the verbs with &#x60;!&#x60; as
the leading character of their type: these represent the class of
computation evaluators.
  </div>
</p></div><div><p>
  <div class="vdoc type-vdoc-paragraph">VPlot spec tries to specify as little as possible. As such it doesn&#x27;t
specify an execution model itself but delegates this to context term
ontologies. VPlot only provides a way to specify evaluation dependency
chains and the mapping between VPlot data structures and evaluator
inputs and outputs.
  </div>
</p></div><div><p>
  <div class="vdoc type-vdoc-paragraph">Following principles apply:
  </div>
</p></div>
    <ol>
      <li>The different evaluator verb types only specify the means to access
  and process the VPlot data structure itself. These
  &#x60;evaluator types&#x60; are defined by the VPlot specification(s).</li>
      <li><div><p>
  <div class="vdoc type-vdoc-paragraph">All computation (f.ex. flow control and method call) semantics are
  specified by the first vplot param of the evaluator verb, ie. the
  &#x60;computation id&#x60;. This specification shall be provided by the
  ontology that defines the context-term of the computation id param.
  </div>
</p></div></li>
      <li><div><p>
  <div class="vdoc type-vdoc-paragraph">If the computation id doesn&#x27;t have a context-term of if the
  specification denotes the computation id to be a &#x60;trivial name&#x60;
  then the computation is a &#x60;context scope lookup path&#x60;.
  </div>
</p></div></li>
      <li><div><p>
  <div class="vdoc type-vdoc-paragraph">When a computation evaluator is evaluated all of its vparams are
  evaluated first in an order defined by the evaluation context and
  their results stores as evaluation arguments.
  </div>
</p></div></li>
      <li><div><p>
  <div class="vdoc type-vdoc-paragraph">The evaluation context is then searched for an implementation for the
  evaluator type / computation id combination. If none is found the
  context does not implement the computation and the whole evaluation
  chain is rejected.
  </div>
</p></div></li>
      <li><div><p>
  <div class="vdoc type-vdoc-paragraph">The evaluation implementation is resolved with the evaluation
  arguments and its result is the result of the computation
  evaluator.
  </div>
</p></div></li>
    </ol>

<blockquote class="vdoc type-revdoc-example">
    <span class="vdoc type-vdoc-node">
Editorial Note: this section should be greatly improved.
The purpose of computation verbs lies more on representing various
conversions (as part of dynamic operations such as web API route
mapping) and less on clever SPARQL trickery. The illustration here uses
(questionable) SPARQL primarily for consistency.</span>

</blockquote>
<blockquote class="vdoc type-revdoc-example">
    <span id="example_verb_computation" class="vdoc type-vdoc-node">
    <h3><a aria-label="§" href="#example_verb_computation">§ </a>Computation selector example</h3>
Triple pattern &#x60;?s &#x3C;urn:valos:!$valk.add$number.10$.@!$.myVal@@&#x3E; ?o&#x60;
matches like:
<pre><code><span class="vdoc type-vdoc-node">
  ?_:0  V:scope ?s
      ; V:name &#x22;myVal&#x22;
      ; V:value ?myVal
  . FILTER (?o === 10 + ?myVal)
</span>
</code></pre></span>

</blockquote>
  </section>

  </section>

  </section>

  </section>

  <section id="section_vrid" class="vdoc type-vdoc-chapter">
    <h3><a aria-label="§" href="#section_vrid">§ </a>VRID is a stable identifier of a global resource or a fixed sub-resource</h3>
<div><p>
  <div class="vdoc type-vdoc-paragraph">
A VRID is a VPlot which has VGRID as its first production
(via vgrid-tail).
  </div>
</p></div>
<blockquote class="vdoc type-revdoc-example">
    <span id="main_vrid_rules" class="vdoc type-vdoc-node">
    <h3><a aria-label="§" href="#main_vrid_rules">§ </a>Informative VRID rules</h3>
<pre><code><span class="vdoc type-vdoc-node">  vrid        = &#x22;@&#x22; &#x22;$&#x22; vgrid &#x22;@&#x22; *(vstep &#x22;@&#x22;) &#x22;@&#x22;
  vgrid       = format-term &#x22;.&#x22; vgrid-value *vparam
</span>
</code></pre></span>

</blockquote>
  <section id="section_vgrid" class="vdoc type-vdoc-chapter">
    <h3><a aria-label="§" href="#section_vgrid">§ </a>VGRID identifies global resources - primary keys, free ownership, concrete state</h3>
<div><p>
  <div class="vdoc type-vdoc-paragraph">
The VGRID uniquely identifies a *global resource*. If a VRID contains
a VGRID and no verbs this global resource is also the
*referenced resource* of the VRID itself.
  </div>
</p></div>
<blockquote class="vdoc type-revdoc-example">
    <span id="main_vgrid_rules" class="vdoc type-vdoc-node">
    <h3><a aria-label="§" href="#main_vgrid_rules">§ </a>Informative VGRID rules</h3>
<pre><code><span class="vdoc type-vdoc-node">  vgrid         = format-term &#x22;.&#x22; vgrid-value *vparam
  format-term   = &#x22;~&#x22; 1*unreserved-nt
  vgrid-value   = 1*unreserved-nt

  unreserved-nt = ALPHA / DIGIT / &#x22;-&#x22; / &#x22;_&#x22; / &#x22;.&#x22;
  ALPHA         = %x41-5A / %x61-7A                         ; A-Z / a-z
  DIGIT         = %x30-39                                   ; 0-9
</span>
</code></pre></span>

</blockquote><div><p>
  <div class="vdoc type-vdoc-paragraph">
The format-term defines the global resource identifier schema as well
as often some (or all) characteristics of the resource.
  </div>
</p></div><div><p>
  <div class="vdoc type-vdoc-paragraph">format-term and vgrid-value are subsets of verb-type and vvalue; VGRID
restricts the grammar of these to unreserved-nt as specified in
the <a href="https://tools.ietf.org/html/rfc3986" class="vdoc type-vdoc-reference">URI specification</a>).
  </div>
</p></div>
<blockquote class="vdoc type-revdoc-example">
    <span class="vdoc type-vdoc-node">
Note: when using base64 encoded values as VGRID vvalue, use the
url-and-filename-ready<a href="https://tools.ietf.org/html/rfc4648#section-5" class="vdoc type-vdoc-reference">base64url characters</a>.</span>

</blockquote>
  </section>
<div><p>
  <div class="vdoc type-vdoc-paragraph">
The VRID can be directly used as the NSS part of an &#x27;urn:valos:&#x27;
prefixed URI.
  </div>
</p></div><div><p>
  <div class="vdoc type-vdoc-paragraph">Each valospace resource is identified by a VRID.
  </div>
</p></div><div><p>
  <div class="vdoc type-vdoc-paragraph">If a resource VRID has only VGRID part but no verbs the resource is
called a global resource.
  </div>
</p></div><div><p>
  <div class="vdoc type-vdoc-paragraph">If a resource VRID has verbs then the verbs describe a fixed path from
the global resource of its initial VGRID part to the resource itself.
The resource is called a *fixed sub-resource* of that global resource.
  </div>
</p></div><div><p>
  <div class="vdoc type-vdoc-paragraph">Each resource is affiliated with an event log of its global resource.
  </div>
</p></div><div><p>
  <div class="vdoc type-vdoc-paragraph">All direct VRID context-terms are references to this event log <a href="https://w3c.github.io/json-ld-syntax/#the-context" class="vdoc type-vdoc-reference">JSON-LD context</a>.
  </div>
</p></div>
  <section id="section_vrid_event_log" class="vdoc type-vdoc-chapter">
    <h3><a aria-label="§" href="#section_vrid_event_log">§ </a>VRID is affiliated with an event log</h3>
<div><p>
  <div class="vdoc type-vdoc-paragraph">
The resource identified by a VRID is always affiliated with an event
log of its global resource. Because the VRID doesn&#x27;t contain the
locator information of this event log it must be discoverable from the
context where the VRID is used.
  </div>
</p></div><div><p>
  <div class="vdoc type-vdoc-paragraph">All context-terms of the VGRID and VRID vparams are references to the
event log <a href="https://w3c.github.io/json-ld-syntax/#the-context" class="vdoc type-vdoc-reference">JSON-LD context</a> (Note: this applies only to immediate but not to nested vparams).
  </div>
</p></div><div><p>
  <div class="vdoc type-vdoc-paragraph">Global resources can be transferred between event logs. To maintain
immutability across these transfers VGRID&#x27;s must not contain chronicle
or other non-identifying locator information. Similar to URN&#x27;s VRID&#x27;s
always relies external structures and systems for carrying locator
information.

  </div>
</p></div>
<blockquote class="vdoc type-revdoc-example">
    <span class="vdoc type-vdoc-node">Note: uuid v4 (format term &#x60;~u4&#x60;) is recommended for
now, but eventually VGRID generation will be tied to the
deterministic event id chain (format term &#x60;~cc&#x60;).
This in turn should be seeded by some ValOS authority.</span>

</blockquote>
  </section>

  <section id="section_vrid_equivalence" class="vdoc type-vdoc-chapter"><div><p>
  <div class="vdoc type-vdoc-paragraph">
Two VRIDs refer to the same resource iff their URN representations are <a href="https://tools.ietf.org/html/rfc8141#section-3" class="vdoc type-vdoc-reference">urn-equivalent</a>(i.e. if the two VRIDs are equivalent after section 3.1. case
normalization for step 3. percent-encoding case normalization).
  </div>
</p></div><div><p>
  <div class="vdoc type-vdoc-paragraph">Maintaining the consistency between this lexical equivalence and the
semantic equivalence of a resource which has been transferred between
event logs without having to dereference VRIDs is useful but has
implications.
<blockquote>Rule: When resources are transferred between event logs
  the semantics of their context terms and body-parts must remain
  equivalent.</blockquote>
  </div>
</p></div><div><p>
  <div class="vdoc type-vdoc-paragraph">A *simple equivalence* is that two simple prefix term definitions
resolve to the same URI. An *extended equivalence* is when two extended
term definitions in the source and target event logs are equivalent
after normalization. These two equivalences are [will be] defined by
this document.
  </div>
</p></div><div><p>
  <div class="vdoc type-vdoc-paragraph">More complex equivalences are outside the scope of this document but
can be defined by specifications specifying segment types. These
equivalences might take details of the particular verb-type into
account and/or specify context definition additions which do not change
the equivalence semantics.
  </div>
</p></div>
  </section>

  <section id="section_fixed_sub_resources" class="vdoc type-vdoc-chapter">
    <h3><a aria-label="§" href="#section_fixed_sub_resources">§ </a>VRID verbs identify fixed sub-resources - fixed ownership, inferred state, &#x27;secondary keys&#x27;</h3>
<div><p>
  <div class="vdoc type-vdoc-paragraph">In VRID context the vsteps-tail that follows the VGRID specifies
a fixed path from the global resource to a *fixed sub-resource* of the
global resource. The triple constraints of each verb in that path are
_inferred as triples_ for the particular resource that that verb affects.
  </div>
</p></div><div><p>
  <div class="vdoc type-vdoc-paragraph"><blockquote>Principle: a fixed sub-resource using a particular
vsteps-tail in its identifying VRID will always infer the triples that
are required to satisfy the same vsteps-tail in a query context which
starts from the same global resource.</blockquote>
  </div>
</p></div><div><p>
  <div class="vdoc type-vdoc-paragraph">This fixed triple inference is the meat and bones of the fixed
sub-resources: they allow for protected, constrained semantics to be
expressed in the valospace resources. This allows both simplified
semantics (eg. properties _cannot_ be renamed so the complex
functionality doesn&#x27;t need to be supported on fabric level), more
principled mechanism for chronicle crypto behaviours (permission
relations are fixed sub-resources which simplifies security
analysis but retains valospace convenience) and also a mechanism for
expressing non-trivial resources such as hypertwin resources.
  </div>
</p></div><div><p>
  <div class="vdoc type-vdoc-paragraph">The sub-resources can be nested and form a tree with the global
resource as the root. Typical verb sub-segments specify the edges in
this tree (some verbs only specify the current node resource further
without specifying a new edge). The global resource is the host
resource for the first verb; the sub-resource of that segment is the
host resource of the second verb and so on.
  </div>
</p></div><div><p>
  <div class="vdoc type-vdoc-paragraph">As the VRID identities of the sub-resources are structurally fixed to
this tree the coupling between host and sub-resource must be static.
The typical implementation for this is an ownership coupling.
  </div>
</p></div>
  </section>

  <section id="section_vgrid_types" class="vdoc type-vdoc-chapter">
    <h3><a aria-label="§" href="#section_vgrid_types">§ </a>List of VGRID formats:</h3>
<div><p>
  <div class="vdoc type-vdoc-paragraph">
VGRID context-term specifies the particular identifier format and
possible semantics of the identified global resource. ValOS kernel
reserves all context-terms matching &#x27;&#x22;i&#x22; 2( ALPHA / DIGIT )&#x27; for
itself with currently defined formats exhaustively listed here.
      
  </div>
</p></div>
  <section id="section_vgrid_uuid_v4" class="vdoc type-vdoc-chapter">
    <h3><a aria-label="§" href="#section_vgrid_uuid_v4">§ </a>VGRID format &#x22;&#x60;~u4&#x60;&#x22;: UUID v4 of a native, insecure resource</h3>
<div><p>
  <div class="vdoc type-vdoc-paragraph">
An identifier for native valospace resource with an event log.
This is insecure as there are no guarantees against resource id
collisions by malicious event logs. These identifiers can thus only be
used in trusted, protected environments.
  </div>
</p></div>
  </section>

  <section id="section_vgrid_content_hash" class="vdoc type-vdoc-chapter">
    <h3><a aria-label="§" href="#section_vgrid_content_hash">§ </a>VGRID format &#x22;&#x60;~bvo&#x60;&#x22;: The content hash of Binary ValOS object</h3>
<div><p>
  <div class="vdoc type-vdoc-paragraph">
An identifier of an immutable octet-stream, with the content hash in
the vvalue.
  </div>
</p></div>
  </section>

  <section id="section_vgrid_platonic_resource" class="vdoc type-vdoc-chapter">
    <h3><a aria-label="§" href="#section_vgrid_platonic_resource">§ </a>VGRID format &#x22;&#x60;~plt&#x60;&#x22;: The id of an immutable Platonic resource With inferences</h3>
<div><p>
  <div class="vdoc type-vdoc-paragraph">
An identifier of an immutable, procedurally generated resource with its
content inferred from the VPlot embedded in the vvalue.
While of limited use in itself this is useful when used as the
prototype of fixed ghost sub-resources which are quite mutable.
  </div>
</p></div>
  </section>

  <section id="section_vgrid_command_resource_hash" class="vdoc type-vdoc-chapter">
    <h3><a aria-label="§" href="#section_vgrid_command_resource_hash">§ </a>VGRID format &#x22;&#x60;~cih&#x60;&#x22;: The id of a command-id hash-based insecure resource</h3>
<div><p>
  <div class="vdoc type-vdoc-paragraph">
An identifier which has been hashed from a command id, chronicle URI
and a running counter.
  </div>
</p></div>
  </section>

  <section id="section_vgrid_command_chronicle_hash" class="vdoc type-vdoc-chapter">
    <h3><a aria-label="§" href="#section_vgrid_command_chronicle_hash">§ </a>VGRID format &#x22;&#x60;~chr&#x60;&#x22;: The id of a command hash-based chronicle</h3>
<div><p>
  <div class="vdoc type-vdoc-paragraph">
A chronicle identifier which has been hashed from a command id and an
authority URI.
  </div>
</p></div>
  </section>

  <section id="section_vgrid_crypto_chained" class="vdoc type-vdoc-chapter">
    <h3><a aria-label="§" href="#section_vgrid_crypto_chained">§ </a>VGRID format &#x22;&#x60;~ch3&#x60;&#x22;: The id of Crypto-Hash-CHained secure CHronicle resource</h3>
<div><p>
  <div class="vdoc type-vdoc-paragraph">
An identifier of a native, secure valospace resource with an event log.
This id is deterministically derived from the most recent hash-chain
event log entry of the particular event which created it, the
cryptographic secret of the creating identity and a salt, thus ensuring
collision resistance and a mechanism for creator to prove their claim
to the resource.
  </div>
</p></div>
  </section>

  <section id="section_vgrid_authority_root" class="vdoc type-vdoc-chapter">
    <h3><a aria-label="§" href="#section_vgrid_authority_root">§ </a>VGRID format &#x22;&#x60;~aur&#x60;&#x22;: The id of an authority root resource</h3>
<div><p>
  <div class="vdoc type-vdoc-paragraph">
The fixed identifier of an immovable root resource of an authority
chronicle. The authority VGRID param equals to the authority URI.
  </div>
</p></div>
  </section>

  <section id="section_vgrid_ghost" class="vdoc type-vdoc-chapter">
    <h3><a aria-label="§" href="#section_vgrid_ghost">§ </a>VGRID format &#x22;&#x60;~gh&#x60;&#x22;: The derived Hash id of a native, insecure Ghost resource</h3>
<div><p>
  <div class="vdoc type-vdoc-paragraph">
This is a legacy format for native ghost resources, with id created
from the hash of the &#x27;ghost path&#x27; of the resource.
  </div>
</p></div>
  </section>

  <section id="section_vgrid_raw" class="vdoc type-vdoc-chapter">
    <h3><a aria-label="§" href="#section_vgrid_raw">§ </a>VGRID format &#x22;&#x60;~raw&#x60;&#x22;: The insecure raw text id of a resource</h3>
<div><p>
  <div class="vdoc type-vdoc-paragraph">
An id with an unknown schema.
  </div>
</p></div>
  </section>

  </section>

  <section id="section_vrid_verb_types" class="vdoc type-vdoc-chapter">
    <h3><a aria-label="§" href="#section_vrid_verb_types">§ </a>List of VRID-specific verb type semantics:</h3>
<div><p>
  <div class="vdoc type-vdoc-paragraph">
VRID *verb-type* specifies the relationship category between the
segment host resource and sub-resource, a set of inferred triples as
well as other possible constraints.
  </div>
</p></div>
<blockquote class="vdoc type-revdoc-example">
    <span id="example_shared_vrid_verb_data" class="vdoc type-vdoc-node">
    <h3><a aria-label="§" href="#example_shared_vrid_verb_data">§ </a>Shared example data</h3>
The examples below all share the following triples:<pre><code><span class="vdoc type-vdoc-node">
  &#x3C;urn:valos:$~u4.f00b&#x3E; a V:Entity
      ; V:prototype &#x3C;urn:valos:$~u4.f00b-b507-0763&#x3E;
</span>
</code></pre></span>

</blockquote>
  <section id="section_fixed_ghost" class="vdoc type-vdoc-chapter">
    <h3><a aria-label="§" href="#section_fixed_ghost">§ </a>verb type &#x22;&#x60;_&#x60;&#x22;: fixed subspace sub-resource</h3>
<div><p>
  <div class="vdoc type-vdoc-paragraph">
Ghost sub-resources are products of ghost instantiation. All the ghosts
of the directly _and indirectly_ owned resources of the instance
prototype are flattened as _direct_ fixed sub-resources of the
instance itself. The instance is called *ghost host* of all such ghosts.
  </div>
</p></div>
<blockquote class="vdoc type-revdoc-example">
    <span id="example_fixed_ghost" class="vdoc type-vdoc-node">
    <h3><a aria-label="§" href="#example_fixed_ghost">§ </a>Fixed ghost triple inference</h3>
&#x60;&#x3C;urn:valos:$~u4.f00b@_$~u4.ba54&#x3E;&#x60; reads as &#x22;inside the
instance resource &#x60;f00b&#x60; the ghost of the $~u4 resource &#x60;ba54&#x60;&#x22;
and infers triples:
<pre><code><span class="vdoc type-vdoc-node">
  &#x3C;urn:valos:$~u4.f00b@_$~u4.ba54&#x3E;
        V:ghostHost &#x3C;urn:valos:$~u4.f00b&#x3E;
      ; V:ghostPrototype &#x3C;urn:valos:$~u4.ba54&#x3E;
</span>
</code></pre></span>

</blockquote><div><p>
  <div class="vdoc type-vdoc-paragraph">
In case of deeper instantiation chains the outermost ghost segment
provides inferences recursively to all of its sub-resources; nested
ghost segments wont provide any further inferences.
  </div>
</p></div>
<blockquote class="vdoc type-revdoc-example">
    <span id="example_fixed_ghost_recursive" class="vdoc type-vdoc-node">
    <h3><a aria-label="§" href="#example_fixed_ghost_recursive">§ </a>Recursive ghost triple inference</h3>
&#x60;&#x3C;urn:valos:$~u4.f00b@_$~u4.ba54@_$~u4.b7e4&#x3E;&#x60; reads as &#x22;inside
the instance resource &#x60;f00b&#x60; the ghost of
&#x60;&#x3C;urn:valos:$~u4.ba54@_$~u4.b7e4&#x3E;&#x60;&#x22; and infers triples:
<pre><code><span class="vdoc type-vdoc-node">
  &#x3C;urn:valos:$~u4.f00b@_$~u4.ba54@_$~u4.b7e4&#x3E;
        V:ghostHost &#x3C;urn:valos:$~u4.f00b&#x3E;
      ; V:ghostPrototype &#x3C;urn:valos:$~u4.ba54@_$~u4.b7e4&#x3E;
</span>
</code></pre></span>

</blockquote>
  </section>

  <section id="section_fixed_subspace" class="vdoc type-vdoc-chapter">
    <h3><a aria-label="§" href="#section_fixed_subspace">§ </a>verb type &#x22;&#x60;_&#x60;&#x22;: fixed subspace override</h3>
<div><p>
  <div class="vdoc type-vdoc-paragraph">
Selects a variant resource value for a base resource within a fixed
subspace. The variant resource provides
inferred &#x60;subspacePrototype&#x60; fallbacks to an *inner* subspace and
eventually to the non-variant base resource as well as to the
homologous sub-resource of the host resource inheritancePrototype.
  </div>
</p></div><div><p>
  <div class="vdoc type-vdoc-paragraph">This means that no matter where a subspace variant is defined in
the prototype chain or in the nested sub-structure its value will be
found.
  </div>
</p></div>
<blockquote class="vdoc type-revdoc-example">
    <span id="example_fixed_subspace" class="vdoc type-vdoc-node">
    <h3><a aria-label="§" href="#example_fixed_subspace">§ </a>Fixed subspace triple inference</h3>
&#x60;&#x3C;urn:valos:$~u4.f00b@.$.myProp@_$lang.fi&#x3E;&#x60; is a lang fi variant of
f00b myProp and infers triples:
<pre><code><span class="vdoc type-vdoc-node">
  &#x3C;urn:valos:$~u4.f00b@.$.myProp@_$lang.fi&#x3E; a V:ScopeProperty
      ; V:subspacePrototype &#x3C;urn:valos:$~u4.f00b@.$.myProp&#x3E;
                          , &#x3C;urn:valos:$~u4.f00b-b507-0763@.$.myProp@_$lang.fi&#x3E;
      ; V:language &#x22;fi&#x22;
</span>
</code></pre></span>

</blockquote><div><p>
  <div class="vdoc type-vdoc-paragraph">
Subspace selectors can be used to access language variants,
statically identified ghost variants within an instance, statically
identified Relation&#x27;s etc.
  </div>
</p></div><div><p>
  <div class="vdoc type-vdoc-paragraph">The verb segment-term can also specify triple inferences for *all*
sub-resources in the subspace (not just for the immediate
sub-resource of the selector segment).
  </div>
</p></div>
<blockquote class="vdoc type-revdoc-example">
    <span id="example_fixed_subspace_recursive" class="vdoc type-vdoc-node">
    <h3><a aria-label="§" href="#example_fixed_subspace_recursive">§ </a>Fixed subspace recursive inference</h3>
&#x60;&#x3C;urn:valos:$~u4.f00b@_$~u4.b453@_$lang.fi@_$~u4.b74e@.$.myProp&#x3E;&#x60;
infers triples:
<pre><code><span class="vdoc type-vdoc-node">
  &#x3C;urn:valos:$~u4.f00b@_$~u4.b453@_$lang.fi@_$~u4.b74e@.$.myProp&#x3E; a V:ScopeProperty
      ; V:ghostHost &#x3C;urn:valos:$~u4.f00b&#x3E;
      ; V:ghostPrototype &#x3C;urn:valos:$~u4.b453@_$lang.fi@_$~u4.b74e@.$.myProp&#x3E;
      ; V:subspacePrototype &#x3C;urn:valos:$~u4.f00b@_$~u4.b453@_$~u4.b74e@_$lang.fi@.$.myProp&#x3E;
      ; V:language &#x22;fi&#x22;
</span>
</code></pre></span>

</blockquote>
  </section>

  <section id="section_fixed_scope_property" class="vdoc type-vdoc-chapter">
    <h3><a aria-label="§" href="#section_fixed_scope_property">§ </a>verb type &#x22;&#x60;.&#x60;&#x22;: fixed ScopeProperty</h3>
<div><p>
  <div class="vdoc type-vdoc-paragraph">
Fixed properties infer a type, fixed owner and name.
  </div>
</p></div>
<blockquote class="vdoc type-revdoc-example">
    <span id="example_fixed_scope_property" class="vdoc type-vdoc-node">
    <h3><a aria-label="§" href="#example_fixed_scope_property">§ </a>Fixed scope property triple inference</h3>
&#x60;&#x3C;urn:valos:$~u4.f00b@.$.myProp&#x3E;&#x60; is a resource with fixed name
&#x22;myProp&#x22;, dominant type ScopeProperty, $~u4 resource f00b as the owning
scope and a structurally homologous prototype inside
f00b-b507-0763 and thus infers triples:
<pre><code><span class="vdoc type-vdoc-node">
  &#x3C;urn:valos:$~u4.f00b@.$.myProp&#x3E; a V:ScopeProperty
      ; V:scope &#x3C;urn:valos:$~u4.f00b&#x3E;
      ; V:inheritancePrototype &#x3C;urn:valos:$~u4.f00b-b507-0763@.$.myProp&#x3E;
      ; V:name &#x22;myProp&#x22;
</span>
</code></pre></span>

</blockquote><div><p>
  <div class="vdoc type-vdoc-paragraph">The verbs &#x60;.O.&#x60;, &#x60;.O+&#x60;, and &#x60;.O~&#x60; denote the properties
&#x60;V:value&#x60;, &#x60;V:id&#x60;, and &#x60;V:content&#x27;&#x60; respectively.
These are the primary <em>rdf:object sub-properties</em> of
ScopeProperty, Entity and Media, respectively (the &#x27;O&#x27; in the
verbs stands for rdf:object). When given as a parameter to a primary
resource they modify it with a fixed rdf:object triple.
In addition &#x60;.S-&#x60; and &#x60;.O-&#x60; denote &#x60;V:source&#x60; &#x60;V:target&#x60;
which are the rdf:subject and rdf:object properties of a Relation.
  </div>
</p></div>
<blockquote class="vdoc type-revdoc-example">
    <span id="example_fixed_object" class="vdoc type-vdoc-node">
    <h3><a aria-label="§" href="#example_fixed_object">§ </a>Fixed rdf:object triple inference</h3>
&#x60;&#x3C;urn:valos:$~u4.f00b@-out--$.PERMISSIONS:@.O-$~ih.8766&#x3E;&#x60; is a PERMISSIONS
relation with fixed ~ih target 8766 and infers triples:
<pre><code><span class="vdoc type-vdoc-node">
  &#x3C;urn:valos:$~u4.f00b@-out--$.PERMISSIONS:@.O-$~ih.8766&#x3E; a V:Relation
      ; V:connectedSource &#x3C;urn:valos:$~u4.f00b&#x3E;
      ; V:prototype &#x3C;urn:valos:$~u4.f00b-b507-0763@-out--$.PERMISSIONS:@.O-$~ih.8766&#x3E;
      ; V:name &#x22;PERMISSIONS&#x22;
      ; V:target &#x3C;urn:valos:$~u4.8766&#x3E;
</span>
</code></pre>Mnemonic: these verbs are read right-to-left, eg. &#x60;.O-&#x60; -&#x3E; &#x27;Relation
rdf:object property is V:target&#x27;</span>

</blockquote>
  </section>

  <section id="section_fixed_relation" class="vdoc type-vdoc-chapter">
    <h3><a aria-label="§" href="#section_fixed_relation">§ </a>verb type &#x22;&#x60;*&#x60;&#x22;: fixed Relation</h3>
<div><p>
  <div class="vdoc type-vdoc-paragraph">
Fixed relations infer a type, fixed owner (connector), name and
possibly source and target.
  </div>
</p></div>
<blockquote class="vdoc type-revdoc-example">
    <span id="example_fixed_relation" class="vdoc type-vdoc-node">
    <h3><a aria-label="§" href="#example_fixed_relation">§ </a>Fixed relation triple inference</h3>
&#x60;&#x3C;urn:valos:$~u4.f00b@-out--$.PERMISSIONS@_$.1&#x3E;&#x60; is a resource with
fixed name &#x22;PERMISSIONS&#x22;, dominant type Relation, ~u4 f00b as the
source, a structurally homologous prototype inside f00b-b507-0763
and thus infers triples:
<pre><code><span class="vdoc type-vdoc-node">
  &#x3C;urn:valos:$~u4.f00b@-out--$.PERMISSIONS&#x3E; a V:Relation
      ; V:connectedSource &#x3C;urn:valos:$~u4.f00b&#x3E;
      ; V:inheritancePrototype &#x3C;urn:valos:$~u4.f00b-b507-0763@-out--$.PERMISSIONS&#x3E;
      ; V:name &#x22;PERMISSIONS&#x22;
  &#x3C;urn:valos:$~u4.f00b@-out--$.PERMISSIONS@_$.1&#x3E; a V:Relation
      ; V:subspacePrototype &#x3C;urn:valos:$~u4.f00b@-out--$.PERMISSIONS&#x3E;
                          , &#x3C;urn:valos:$~u4.f00b-b507-0763@-out--$.PERMISSIONS@_$.1&#x3E;
</span>
</code></pre></span>

</blockquote>
  </section>

  <section id="section_fixed_entity" class="vdoc type-vdoc-chapter">
    <h3><a aria-label="§" href="#section_fixed_entity">§ </a>verb type &#x22;&#x60;+&#x60;&#x22;: fixed Entity</h3>
<div><p>
  <div class="vdoc type-vdoc-paragraph">
Fixed entities infer a type, fixed owner (parent) and name.
  </div>
</p></div>
<blockquote class="vdoc type-revdoc-example">
    <span id="example_fixed_entity" class="vdoc type-vdoc-node">
    <h3><a aria-label="§" href="#example_fixed_entity">§ </a>Fixed Entity triple inference</h3>
&#x60;&#x3C;urn:valos:$~u4.f00b@+$.Scripts&#x3E;&#x60; has a fixed name &#x22;scripts&#x22;,
dominant type Entity, $~u4 resource f00b as the owning container and
a structurally homologous prototype inside f00b-b507-0763 and thus
infers triples:
<pre><code><span class="vdoc type-vdoc-node">
  &#x3C;urn:valos:$~u4.f00b@+$.Scripts&#x3E; a V:Entity
      ; V:parent &#x3C;urn:valos:$~u4.f00b&#x3E;
      ; V:inheritancePrototype &#x3C;urn:valos:$~u4.f00b-b507-0763@+$.Scripts&#x3E;
      ; V:name &#x22;scripts&#x22;
</span>
</code></pre></span>

</blockquote>
  </section>

  <section id="section_fixed_media" class="vdoc type-vdoc-chapter">
    <h3><a aria-label="§" href="#section_fixed_media">§ </a>verb type &#x22;&#x60;~&#x60;&#x22;: fixed Media</h3>
<div><p>
  <div class="vdoc type-vdoc-paragraph">
Fixed medias infer a type, fixed owner (folder) and name.
  </div>
</p></div>
<blockquote class="vdoc type-revdoc-example">
    <span id="example_fixed_media" class="vdoc type-vdoc-node">
    <h3><a aria-label="§" href="#example_fixed_media">§ </a>Fixed Media triple inference</h3>
&#x60;&#x3C;urn:valos:$~u4.f00b@~$.foo.vs&#x3E;&#x60; has a fixed name &#x22;foo.vs&#x22;, dominant
type Media, $~u4 resource f00b as the owning folder and a structurally
homologous prototype inside f00b-b507-0763 and thus infers triples:
<pre><code><span class="vdoc type-vdoc-node">
  &#x3C;urn:valos:$~u4.f00b@~$.foo.vs&#x3E; a V:Media
      ; V:folder &#x3C;urn:valos:$~u4.f00b&#x3E;
      ; V:inheritancePrototype &#x3C;urn:valos:$~u4.f00b-b507-0763@~$.foo.vs&#x3E;
      ; V:name &#x22;foo.vs&#x22;
</span>
</code></pre></span>

</blockquote>
  </section>

  </section>

  </section>

  <section id="section_grammar" class="vdoc type-vdoc-chapter">
    <h3><a aria-label="§" href="#section_grammar">§ </a>Collected VPlot ABNF grammar</h3>
<div><p>
  <div class="vdoc type-vdoc-paragraph">The VPlot grammar is an LL(1) grammar. It is recursive be virtue of
vvalue productions which can nest VPlots themselves without additional
encoding.
  </div>
</p></div><div><p>
  <div class="vdoc type-vdoc-paragraph">The list of definitive rules:
<pre><code><span class="vdoc type-vdoc-node">  vplot         = &#x22;@&#x22; *(vstep &#x22;@&#x22;) &#x22;@&#x22;
  vstep         = [ verb-type ] *vparam
  vparam        = &#x22;$&#x22; [ context-term ] &#x22;.&#x22; vvalue
  vvalue        = vplot / &#x22;$&#x22; / 1*( unencoded / pct-encoded )

  verb-type     = 1*unencoded
  context-term  = 1*unreserved
  unencoded     = unreserved / &#x22;!&#x22; / &#x22;*&#x22; / &#x22;&#x27;&#x22; / &#x22;(&#x22; / &#x22;)&#x22;
  unreserved    = unreserved-nt / &#x22;~&#x22;
  unreserved-nt = ALPHA / DIGIT / &#x22;-&#x22; / &#x22;_&#x22; / &#x22;.&#x22;
  pct-encoded   = &#x22;%&#x22; HEXDIG HEXDIG

  ALPHA         = %x41-5A / %x61-7A                         ; A-Z / a-z
  HEXDIG        = DIGIT / &#x22;A&#x22; / &#x22;B&#x22; / &#x22;C&#x22; / &#x22;D&#x22; / &#x22;E&#x22; / &#x22;F&#x22; ; 0-9 / A-F
  DIGIT         = %x30-39                                   ; 0-9</span>
</code></pre>
  </div>
</p></div><div><p>
  <div class="vdoc type-vdoc-paragraph">In addition there are pseudo-rules which are not used by an LL(1)
parser but which have well-defined meaning and can thus be referred to
from other documents.
  </div>
</p></div><div><p>
  <div class="vdoc type-vdoc-paragraph">The list of informative pseudo-rules:
<pre><code><span class="vdoc type-vdoc-node">  vverb           = verb-type *vparam
  vcontext-param  = &#x22;$&#x22; context-term &#x22;.&#x22; vvalue

  vrid            = &#x22;@&#x22; &#x22;$&#x22; vgrid &#x22;@&#x22; *(vstep &#x22;@&#x22;) &#x22;@&#x22;
  vgrid           = format-term &#x22;.&#x22; vgrid-value *vparam
  format-term     = &#x22;~&#x22; 1*(ALPHA / DIGIT / &#x22;_&#x22;)
  vgrid-value     = 1*( unencoded / pct-encoded )

  context-term-ns = ALPHA 0*30unreserved-nt ( ALPHA / DIGIT )
</span>
</code></pre>
  </div>
</p></div><div><p>
  <div class="vdoc type-vdoc-paragraph">There are couple notes not explicitly expressed by the the grammar
itself. These notes primarily relate to LL(1)-parseability:
  </div>
</p></div>
    <ul>
      <li>Pseudo-rule &#x27;vrid&#x27;: this class contains all &#x27;vplot&#x27; productions with
  &#x27;vgrid&#x27; as their first expansion.</li>
      <li><div><p>
  <div class="vdoc type-vdoc-paragraph">Pseudo-rule &#x27;context-term-ns&#x27;: this class contains all &#x27;context-term&#x27;
  expansions which match this more restrictive specification (max 32
  chars, special chars only in the middle). All &#x27;context-term&#x27;s which
  are plain namespace prefixes should be restricted to this rule as
  this is the prefix grammar of some relevant prefix context.
  
<blockquote class="vdoc type-revdoc-example">
    <span class="vdoc type-vdoc-node">Editorial Note: which context was this again? Neither
    SPARQL, Turtle nor JSON-LD have this limitation.</span>

</blockquote>
  </div>
</p></div></li>
      <li><div><p>
  <div class="vdoc type-vdoc-paragraph">The nesting hierarchy can be manually quickly established by first
  splitting a valid VPlot string by the delimiter regex /(@$.)/
  (retaining these delimiters in the result). Then a tree structure is
  formed by traversing the array from left to right and dividing it to
  different nesting depths. The nesting depth is increased for the
  initial &#x22;@&#x22; and for each &#x22;@&#x22; that is preceded by a &#x22;.&#x22; (corresponds
  to the &#x27;vplot&#x27; production prefix of some &#x27;short-param&#x27; production)
  and reducing the nesting depth for each &#x22;@&#x22; that is succeeded by a
  &#x22;$&#x22;, &#x22;@&#x22; or EOF (corresponds to the terminator of the last
  &#x27;vgrid&#x27; or &#x27;verb&#x27; production of some &#x27;vplot&#x27; production). All
  remaining &#x22;@&#x22; correspond to non-final &#x27;vgrid&#x27; or &#x27;verb&#x27; production
  terminators of some &#x27;vplot&#x27; rule production and thus don&#x27;t change the
  nesting depth.
  </div>
</p></div></li>
    </ul>

  </section>

  <section id="section_encoding_considerations" class="vdoc type-vdoc-chapter">
    <h3><a aria-label="§" href="#section_encoding_considerations">§ </a>VPlot design considerations and case studies</h3>
<div><p>
  <div class="vdoc type-vdoc-paragraph">
This section contains considerations on the choice of character set and
on where and how VPlots need or don&#x27;t need to be encoded. There&#x27;s a
historical emphasis on the decision of which characters to use as
delimiters (ie. &#x22;@&#x22;, and &#x22;$&#x22;).
  </div>
</p></div>
  <section id="section_robust_composition" class="vdoc type-vdoc-chapter">
    <h3><a aria-label="§" href="#section_robust_composition">§ </a>VPlot composition and decomposition should be robust</h3>

  <section id="section_no_contextual_delimiters" class="vdoc type-vdoc-chapter">
    <h3><a aria-label="§" href="#section_no_contextual_delimiters">§ </a>No contextual delimiters</h3>
<div><p>
  <div class="vdoc type-vdoc-paragraph">
If a character is a delimiter in some context within a VPlot then this
character must always encoded when not used as a delimiter.
  </div>
</p></div>
  </section>

  <section id="section_consistent_encoding" class="vdoc type-vdoc-chapter">
    <h3><a aria-label="§" href="#section_consistent_encoding">§ </a>All value segments are encoded and decoded using encodeURIComponent</h3>
<div><p>
  <div class="vdoc type-vdoc-paragraph">
Characters not encoded are ruled out from structural delimiters.
This leaves &#x22;?&#x22; | &#x22;#&#x22; and &#x22;/&#x22; | &#x22;:&#x22; | &#x22;@&#x22; and &#x22;$&#x22; | &#x22;+&#x22; | &#x22;;&#x22; | &#x22;,&#x22; | &#x22;=&#x22; | &#x22;&#x26;&#x22;
  </div>
</p></div>
  </section>

  </section>

  <section id="section_unencoded_contexts" class="vdoc type-vdoc-chapter">
    <h3><a aria-label="§" href="#section_unencoded_contexts">§ </a>Contexts where VPlot doesn&#x27;t need encoding</h3>
<div><p>
  <div class="vdoc type-vdoc-paragraph">
In general VPlots don&#x27;t require encoding in contexts where the VPlot
delimiters &#x22;@&#x22; / &#x22;$&#x22; and the encodeURIComponent result character set
ALPHA / DIGIT / &#x22;-&#x22; / &#x22;_&#x22; / &#x22;.&#x22; / &#x22;~&#x22; / &#x22;!&#x22; / &#x22;*&#x22; / &#x22;&#x27;&#x22; / &#x22;(&#x22; / &#x22;)&#x22;
can be used.
<blockquote>Editorial Note: &#x22;(&#x22; and &#x22;)&#x22; can in principle be
  substantially inconvenient in many contexts. But as they&#x27;re grouped
  with &#x22;!&#x22; / &#x22;*&#x22; / &#x22;&#x27;&#x22; which have their uses in verb-type&#x27;s all
  five are for now retained as allowed characters.</blockquote>
  </div>
</p></div>
  <section id="section_unencoded_in_rfc_3986_segment_nz" class="vdoc type-vdoc-chapter">
    <h3><a aria-label="§" href="#section_unencoded_in_rfc_3986_segment_nz">§ </a>As RFC 3986 URI segment-nz component</h3>
<div><p>
  <div class="vdoc type-vdoc-paragraph">
VPlots can be used as-is in URI path parts (except as segment-nz-nc, see below).
This rules out &#x22;?&#x22;, &#x22;#&#x22;, &#x22;/&#x22; from structural delimiters
  </div>
</p></div>
  </section>

  <section id="section_unencoded_in_sequences" class="vdoc type-vdoc-chapter">
    <h3><a aria-label="§" href="#section_unencoded_in_sequences">§ </a>As a typical sequence entry</h3>
<div><p>
  <div class="vdoc type-vdoc-paragraph">
Rules out &#x22;,&#x22; | &#x22;;&#x22; from structural delimiters
  </div>
</p></div>
  </section>

  <section id="section_unencoded_in_rfc_3986_query" class="vdoc type-vdoc-chapter">
    <h3><a aria-label="§" href="#section_unencoded_in_rfc_3986_query">§ </a>As part of RFC 3986 URI query component when consumer is known not to decode</h3>
<div><p>
  <div class="vdoc type-vdoc-paragraph">
VPlot can and is intended to be used as-is in the query part (even as
the right-hand side value of &#x22;=&#x22;) <em>as long as the URI
consumer or possible middlewares don&#x27;t perform x-www-form-urlencoded
(or other) decoding of the key-value pairs</em>before VPlot expansion.
  </div>
</p></div><div><p>
  <div class="vdoc type-vdoc-paragraph">Rules out &#x22;=&#x22; , &#x22;&#x26;&#x22; from structural characters.
<blockquote>Note: This is completely regular. If the consumer is
  known to explicitly decode query values and because VPlots can
  contain &#x22;%&#x22; characters they must be appropriately symmetrically
  encoded. This can result in double encoding. However as the intent is
  that VPlot expansion should be considered to be part of <a href="https://tools.ietf.org/html/rfc3986#section-2.4" class="vdoc type-vdoc-reference">the URI parsing and separation itself</a> any  separate encoding and decoding should not be needed.</blockquote>
  </div>
</p></div>
  </section>

  <section id="section_unencoded_in_rfc_3986_fragment" class="vdoc type-vdoc-chapter">
    <h3><a aria-label="§" href="#section_unencoded_in_rfc_3986_fragment">§ </a>As RFC 3986 URI fragment component</h3>
<div><p>
  <div class="vdoc type-vdoc-paragraph">
Doesn&#x27;t rule out any delimiter options not yet ruled out.
  </div>
</p></div>
  </section>

  <section id="section_unencoded_in_rfc_8141_nss" class="vdoc type-vdoc-chapter">
    <h3><a aria-label="§" href="#section_unencoded_in_rfc_8141_nss">§ </a>As RFC 8141 URN NSS components</h3>
<div><p>
  <div class="vdoc type-vdoc-paragraph">
Doesn&#x27;t rule out any delimiter options not yet ruled out.
Specifically this does not rule out &#x22;:&#x22; as that is allowed in NSS sub-parts.
  </div>
</p></div>
  </section>

  <section id="section_unencoded_in_rfc_8141_rq_f" class="vdoc type-vdoc-chapter">
    <h3><a aria-label="§" href="#section_unencoded_in_rfc_8141_rq_f">§ </a>As RFC 8141 URN rq-, and f-component</h3>
<div><p>
  <div class="vdoc type-vdoc-paragraph">
Covered by URI query and fragment sections.
  </div>
</p></div>
  </section>

  </section>

  <section id="section_encoded_contexts" class="vdoc type-vdoc-chapter">
    <h3><a aria-label="§" href="#section_encoded_contexts">§ </a>VPlot must be used escaped/quoted/encoded in following contexts</h3>

  <section id="section_quoted_string" class="vdoc type-vdoc-chapter">
    <h3><a aria-label="§" href="#section_quoted_string">§ </a>In HTTP/1.1 headers always as a quoted-string</h3>
<div><p>
  <div class="vdoc type-vdoc-paragraph">
URI&#x27;s in general need to be quoted here and VPlot is URI-like.
This retains &#x22;@&#x22; as an allowed delimiter.
  </div>
</p></div>
  </section>

  <section id="section_in_rfc_3986_segment_nz_nc" class="vdoc type-vdoc-chapter">
    <h3><a aria-label="§" href="#section_in_rfc_3986_segment_nz_nc">§ </a>In URI relative-part with no scheme must be prefixed with &#x22;./&#x22;</h3>
<div><p>
  <div class="vdoc type-vdoc-paragraph">
This retains &#x22;:&#x22; as an allowed delimiter which segment-nz-nc would
otherwise prevent.
  </div>
</p></div>
  </section>

  <section id="section_x_www_form_urlencoded" class="vdoc type-vdoc-chapter">
    <h3><a aria-label="§" href="#section_x_www_form_urlencoded">§ </a>In form fields as x-www-form-urlencoded</h3>
<div><p>
  <div class="vdoc type-vdoc-paragraph">
Encoded and serialized as per <a href="https://url.spec.whatwg.org/#urlencoded-serializing" class="vdoc type-vdoc-reference">https://url.spec.whatwg.org/#urlencoded-serializing</a>
  </div>
</p></div>
  </section>

  </section>

  <section id="section_tilde_problem" class="vdoc type-vdoc-chapter">
    <h3><a aria-label="§" href="#section_tilde_problem">§ </a>The tilde problem with URN RFC 2141 is solved by RFC 8141</h3>
<div><p>
  <div class="vdoc type-vdoc-paragraph">
RFC 2141 reserves &#x22;~&#x22; but encodeURIComponent doesn&#x27;t encode it. To
maintain direct drop-in 2141 compatibility would require disallowing
&#x22;~&#x22; from the character set. This in turn would complicate specific
javascript domain implementations as they would have to encode &#x22;~&#x22;
separately without being able to solely rely on encodeURIComponent.
  </div>
</p></div><div><p>
  <div class="vdoc type-vdoc-paragraph">As this concern is not likely to be a problem in practice anyway we
choose to refer to RFC 8141 for URN&#x27;s which removes &#x22;~&#x22; from the set of
reserved character. This solves this (relatively theoretical) issue.
  </div>
</p></div>
  </section>

  </section>

  </body>
</html>
